# Back-end Project Structure

### `➜  Mern-Chat-App git:(main) tree Frontend -L 2`

```
    Frontend
    ├── eslint.config.js     -> enables real-time bad grammar checks inside the editor, to avoid runtime errors.
    ├── index.html          -> Applincation entry, Vite injects your React app here
    ├── node_modules        -> Installed dependencies(third-party packages) generated by npm install, The app imports code from here at runtime/build time.
    │   ├── @babel
    │   ├── ...
    │   └── zod-validation-error
    ├── package-lock.json   -> Guarantees that everyone installs the exact same dependency versions, every time.
    ├── package.json
    ├── public              -> Static assets: (icons, images)
    │   └── vite.svg
    ├── README.md
    ├── src                 -> Source code (bundled for production) ?
    │   ├── App.css
    │   ├── App.tsx
    │   ├── assets
    │   ├── index.css
    │   └── main.tsx        -> First TypeScript file executed, Creates the React root + Renders <App />
    ├── tsconfig.app.json    -> Used by Vite for browser-side TypeScript compilation.
    ├── tsconfig.json
    ├── tsconfig.node.json
    └── vite.config.ts
```
---

## Login and signup Pages(front-end)

### Packages Needed

#### `react-router-dom`:
    -> just links a React component with an URL path, so that we can make a frontend router.
    -> simulate multi-page behavior inside a single-page application.

```
import { BrowserRouter } from "react-router-dom"
import { Routes, Route } from "react-router-dom"
```
routing components imported from the `react-router-dom` package.

**BrowserRouter (component)**: Links the browser's URL to React, Listens to URL changes (/login, /profile, etc.)
**Routes (component)**: A route matcher, it decides which route to display
**Route (component)**: A single route definition (maps URL to component)

> Route must always be a child of `<Routes>`.

#### `axios`
    -> JavaScript library (so it works on both back & front) used to make HTTP requests from your application to a server or API.
    -> In my case i will be using it to make front-end call my backend API.
    -> axios is preferable than fetch for the following reasons:
        1. automatique error handling of the http request (res.ok()).
        2. automatique JSON parsing

#### `zustand`
    -> Zustand state management library allows us to create our custum global state variables (state + update logic) that are shared across multiple components without prop drilling.
    -> So state lives outside the component tree, Components access it directly.
> Pass state variables to components bla ktrt lhadra

#### `daisyUI`

    -> Tailwind CSS plugin that adds pre-built UI components and themes.
> A plugin is a piece of code that depends on another library or tool + it cannot work alone; it depends on a library or framework + Adds extra features to an existing system.
